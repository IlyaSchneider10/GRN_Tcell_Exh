---
title: "Scenic_50_full_genome"
author: "Ilya"
date: "19/05/2022"
output: html_document
---
  
#Download packages
```{r}
#install.packages("RColorBrewer")

#install.packages("igraph")

#install.packages("dplyr")

#install.packages("openxlsx")

#install.packages("gplots")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("GenomicRanges")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("Homo.sapiens")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("plyranges")

#install.packages("ellipsis")
#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("AUCell")

#if (!require("BiocManager", quietly = TRUE))
#install.packages("BiocManager")
#BiocManager::install("GSEABase")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("GEOquery")
```

#Load packages
```{r}
update.packages("ellipsis")
#library(dplyr)
update.packages("htmltools")
library(GenomicRanges)
library(GenomicFeatures)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(Homo.sapiens)
library(plyranges)
library(AUCell)
library(GSEABase)
library(GEOquery)
library(openxlsx)
library(stringr)
library(gplots)
library(igraph)
library(RColorBrewer)
``` 

#Direcrories
```{r}
main_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/scr"
data_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/data"
analysis_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/analysis"
```

#Edit the input file for the 50 Scenic runs
```{r eval=FALSE, echo=FALSE}
input<-read.csv("/media/ag-cherrmann/cramirez/tcd8ExscSeq/data/maike2020/nina_thimme_raw_counts.csv",header=T, row.names=1)

#Remove RNA genes
input<-t(as.data.frame(input))
input<-input[,17:dim(input)[2]]

#Remove chromosme tags and duplicates
genes<-gsub("\\_.*","",colnames(input))
remove<-which(duplicated(genes))
genes<-genes[-remove] 
input<-input[,-remove]
colnames(input)<-genes
input<-as.data.frame(input)

#Bolouri paper nodes with appropriate nomenclature substitutions
paper_nodes<-c("TNFSF9","TNFRSF9","IL12RB1","IL12RB2","IL21R","FCER1G","CD3","CD8","CD28","PIK3K","EZH2","PRC2","IL2R","RAS","MAPK1","JUN","FOS","BATF","AKT1", "AKT2", "AKT3","FOXO1","EGR2","EGR3","BACH2","ID3","ID2","NFKB1","MTOR","IRF4","TCF3","NFATC2","PPARGC1A","BCL6","PRDM1","NFATC1","CXCR5","TBX21","ZEB2","LAG3","PDCD1","HIF1A","KLRG1","PPARA","CTLA4","HAVCR2","BTLA","NR4A1","CD160","TIGIT","IL15RA","CD244","CD2B4","MYC","RUNX3","EOMES","FAS","FASLG","GZMA","GZMB","PRF1","IFNG")
paper_substitutions<-list("HNF1A","TNFRSF9",c("IL12RB1","IL12RB2"),c("AKT1","AKT2","AKT3"),"TCF3","PRDM1","TBX21","PDCD1","PPARA","TIM3","TNFSF9","FCER1G","MAPK1","PPARGC1A","IL15RA")
names(paper_substitutions)<-c("TCF1","41BB","IL12R","AKT","E2A","BLIMP1","TBET","PD1","PPAR","TIM3","CD137L","CD3","MAPK","PGC1A","IL15R")

#Keep 5000 genes with highest variance, they must include all the paper nodes
input_var<-apply(input,2,var)
input_var_sorted<-sort(input_var,decreasing =T)
paper_nodes_in_input<-which(names(input_var_sorted) %in% paper_nodes)
input_genes<-head(sort(input_var,decreasing =T),5000)
paper_nodes_left_out<-paper_nodes_in_input[paper_nodes_in_input>=5000]
paper_nodes_left_out<-input_var_sorted[paper_nodes_left_out]
paper_nodes_left_out<-paper_nodes_left_out[paper_nodes_left_out>0]
input_genes<-append(input_genes,paper_nodes_left_out)
input<-input[,names(input_genes)]
```

#Export the input table
```{r eval=FALSE, echo=FALSE}
setwd("/media/ag-cherrmann/ischneider/GRNTcellExh/data/SCENIC50/Input")
write.table(input, file='scenic_input_full_genome.tsv', quote=FALSE, sep='\t', row.names = T)
#Code for bash to iterate Scenic 50 times
#bash /media/ag-cherrmann/ischneider/GRNTcellExh/scr/Scenic.txt

#Save the table
setwd(analysis_directory)
write.table(input, file='scenic_input_full_genome.tsv', quote=FALSE, sep='\t', row.names = T)
```

#Open input table
```{r}
input<-read.table(paste0("/media/ag-cherrmann/ischneider/GRNTcellExh/data/SCENIC50/Input","/scenic_input_full_genome.tsv"),sep='\t',header=T)

#Bolouri paper nodes with appropriate nomenclature substitutions
paper_nodes<-c("TNFSF9","TNFRSF9","IL12RB1","IL12RB2","IL21R","FCER1G","CD3","CD8","CD28","PIK3K","EZH2","PRC2","IL2R","RAS","MAPK1","JUN","FOS","BATF","AKT1", "AKT2", "AKT3","FOXO1","EGR2","EGR3","BACH2","ID3","ID2","NFKB1","MTOR","IRF4","TCF3","NFATC2","PPARGC1A","BCL6","PRDM1","NFATC1","CXCR5","TBX21","ZEB2","LAG3","PDCD1","HIF1A","KLRG1","PPARA","CTLA4","HAVCR2","BTLA","NR4A1","CD160","TIGIT","IL15RA","CD244","CD2B4","MYC","RUNX3","EOMES","FAS","FASLG","GZMA","GZMB","PRF1","IFNG")
paper_substitutions<-list("HNF1A","TNFRSF9",c("IL12RB1","IL12RB2"),c("AKT1","AKT2","AKT3"),"TCF3","PRDM1","TBX21","PDCD1","PPARA","TIM3","TNFSF9","FCER1G","MAPK1","PPARGC1A","IL15RA")
names(paper_substitutions)<-c("TCF1","41BB","IL12R","AKT","E2A","BLIMP1","TBET","PD1","PPAR","TIM3","CD137L","CD3","MAPK","PGC1A","IL15R")
```

#Select all TFs from aucell files
```{r}
#Number of scenic runs
n=50 

#Open all aucell files and keep TFs from them
aucell_tfs<-vector("list",length=n)
names(aucell_tfs)<-seq(n)
for (x in seq(n)){
  aucell<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome/run_",as.character(x),"/aucell.csv"),header=T,row.names = 1)
  aucell_tfs[[as.character(x)]]<-colnames(aucell)
}

aucell_tfs<-lapply(aucell_tfs, gsub, pattern="[...]",replacement="")
scenic_output_tfs<-unique(unlist(aucell_tfs))
```

#Adj files
```{r echo=FALSE, eval=FALSE}
#Open adj files
adj_interactions<-vector("list",length=n)
names(adj_interactions)<-seq(n)
for (x in seq(n)){
  adj<-read.table(paste0(data_directory,"/SCENIC50/Output_full_genome/run_",as.character(x),"/adj.tsv"),sep='\t',header=T)
  adj_interactions[[as.character(x)]]<-adj
}
```

#Get targets for TFs from reg files
```{r}
#Get target column from each reg file
reg_targets<-vector("list",length=n)
names(reg_targets)<-seq(n)
for (x in seq(n)){
  reg<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome/run_",as.character(x),"/reg.csv"),header=T)
  reg_targets[[as.character(x)]]<-reg
}

change_reg_format<-function(r){
  names<-c(r[2,1:2],r[1,3:dim(r)[2]])
  y<-setNames(r,names)
  y<-y[-c(1,2),]
}

reg_targets<-lapply(reg_targets,change_reg_format)
for (x in names(reg_targets)){
  reg_targets[[x]]<-split(reg_targets[[x]],reg_targets[[x]]$TF)
}

for (x in names(reg_targets)){
  for (y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-reg_targets[[x]][[y]]$TargetGenes
  }
}

#Extract target names
extract_targets <- function(x){
  targets <- regmatches(x, gregexpr("'[^']*'", x))[[1]] 
  gsub("'", '', targets)
}

extract_all_unique_targets<-function(obj){
  unique(extract_targets(paste0(c(obj),collapse = "")))
}

for (x in names(reg_targets)){
  for(y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-extract_all_unique_targets(reg_targets[[x]][[y]])
  }
}

regulons<-reg_targets
for (x in names(reg_targets)){
  for(y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-reg_targets[[x]][[y]][reg_targets[[x]][[y]] %in% scenic_output_tfs] #we keep not only TF->TF interactions
  }
}

#Remove self regulation
for (y in names(reg_targets)){
  for (x in scenic_output_tfs){
    lookup<-x==reg_targets[[y]][[x]]
    pos<-which(lookup==T)
    if(sum(lookup)!=0){
      reg_targets[[y]][[x]]<-reg_targets[[y]][[x]][-c(pos)]
    }
  }
} 

#Remove TFs with no targets
for (x in names(reg_targets)){
  remove<-which(lapply(reg_targets[[x]], length)==0)
  reg_targets[[x]]<-reg_targets[[x]][-remove]
}

reg_tfs<-c()
for (x in names(reg_targets)){
  reg_tfs<-append(reg_tfs,names(reg_targets[[x]]))
}
reg_tfs<-unique(reg_tfs)
```

#Create a file with all the interactions that we want to keep
```{r}
#Put all interactions in dataframe form
all_interactions<-c()
for (z in names(reg_targets)){
  for(x in names(reg_targets[[z]])){
    for(y in reg_targets[[z]][[x]]){
      all_interactions<-append(all_interactions,paste0(x,"->",y))
    }
  }
}

frequency<-(table(all_interactions))
all_unique_interactions<-names(frequency)
interactions_summary<-as.data.frame(matrix(ncol=3,nrow=length(unlist(all_unique_interactions))))
colnames(interactions_summary)<-c("TF", "target","frequency")
interactions_summary$frequency<-as.numeric(frequency)
interactions_summary$TF<-sub("->.*", "", all_unique_interactions)
interactions_summary$target<-sub(".*->", "", all_unique_interactions)

#Add frequency filter
frequency_filter=40
for(x in seq(dim(interactions_summary)[1])){
  f<-interactions_summary$frequency[x]
  if(f>=frequency_filter){
    interactions_summary[x,"frequency_filter"]<-T
  }else{
    interactions_summary[x,"frequency_filter"]<-F
  }
}

#Dataframe for interactions that pass frequency filter
frequency_summary<-interactions_summary[which(interactions_summary$frequency_filter==T),]
unique(frequency_summary$target)
frequency_summary_nodes<-unique(c(unique(frequency_summary$target),unique(frequency_summary$TF)))
```

#Select best peaks for cistrome
```{r eval=FALSE, echo=FALSE}
#Work with cistrome description file
setwd(data_directory)
cistrome_description<-read.delim("human_factor_full_QC.txt")
cistrome_blood<-cistrome_description[cistrome_description$Tissue_type=="Blood",]

#File 38912 is empty and gives us an error in the loop so we remove it
cistrome_blood<-cistrome_blood[cistrome_blood$DCid!=38912,]
cistrome_blood_file_names<-cistrome_blood$DCid

#Open corresponding files
cistrome_blood_files<-vector("list", length(cistrome_blood_file_names))
names(cistrome_blood_files)<-cistrome_blood_file_names
for (x in cistrome_blood_file_names){
  cistrome_blood_files[[as.character(x)]]<-as.data.frame(read.table(paste0(data_directory,"/human_factor/",as.character(x),"_sort_peaks.narrowPeak.bed"),header = FALSE, sep="\t",stringsAsFactors=FALSE, quote=""))
}

#Keep only TFs that appear in scenic output
names(cistrome_blood_files)<-cistrome_blood$Factor
cistrome_blood_files<-cistrome_blood_files[names(cistrome_blood_files) %in% scenic_output_tfs]

#Split the list into groups according to a TF
cistrome_blood_files<-split(cistrome_blood_files,names(cistrome_blood_files))
cistrome_blood_files<-lapply(cistrome_blood_files, dplyr::bind_rows)

#Select top 1000 peaks for each TF
cistrome_best_peaks<-cistrome_blood_files
for (y in names(cistrome_best_peaks)){
  best_peaks<-unique(head(sort(cistrome_best_peaks[[y]]$V5, decreasing=T),1000))
  keep<-c()
  for (x in best_peaks){
    keep<-append(keep,which(cistrome_best_peaks[[y]]$V5==x))
  }
  cistrome_best_peaks[[y]]<-cistrome_best_peaks[[y]][keep,]
}

#Export cistrome_best_peaks
for (x in names(cistrome_best_peaks)){
  write.csv(cistrome_best_peaks[[x]],paste0(analysis_directory,"/","cistrome_best_peaks/",x,".csv"), row.names = F)
}
```

#Import cistrome_best_peaks
```{r}
best_peaks_file_names<-list.files(paste0(analysis_directory,"/","cistrome_best_peaks"))
cistrome_best_peaks<-list()
for (x in seq_along(best_peaks_file_names)){
  cistrome_best_peaks[[x]]<-read.csv(paste0(analysis_directory,"/","cistrome_best_peaks/",best_peaks_file_names[x]))
}
names(cistrome_best_peaks)<-sub(".csv*.", "", best_peaks_file_names)
```

#Prepare Cistrome peaks for intersection with reference genome
```{r}
#Change peak format
change_peak_format<-function(peak){
  y<-peak[,c(1,2,3,6)]
  new_names<-c("chr","start","end","strand")
  setNames(y,new_names)
}
cistrome_best_peaks<-lapply(cistrome_best_peaks,change_peak_format)

#Extend the peaks by 10 kb in both directions
extension=10000
extend_peaks<-function(peak, e){
  peak<-mutate(peak,start=start-e)
  peak<-mutate(peak,end=end+e)
}
cistrome_extended_peaks<-lapply(cistrome_best_peaks,extend_peaks,e=extension)
for(y in names(cistrome_extended_peaks)){
  for (x in seq_along(cistrome_extended_peaks[[y]]$start)){
    if(cistrome_extended_peaks[[y]]$start[x]<0){
      cistrome_extended_peaks[[y]][x,2]<-0
    }
  }
}
cistrome_granges_peaks<-cistrome_extended_peaks

#Make Granges objects
for (x in names(cistrome_extended_peaks)){
  cistrome_granges_peaks[[x]]<-makeGRangesFromDataFrame(cistrome_extended_peaks[[x]])
}
```

#Overlap peaks with reference genome
```{r}
#Get reference transcripts
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
transcripts <- GenomicFeatures::genes(txdb)

#Get reference genes
TxDb(Homo.sapiens) <- txdb
genes_list <- transcriptsBy(Homo.sapiens, columns = "SYMBOL")
genes <- unlist(genes_list)
cistrome_overlap_transcripts<-lapply(cistrome_granges_peaks, GenomicRanges::intersect, y=transcripts, ignore.strand=T)

#Create overlap and obtain gene names
cistrome_overlap_genes<-lapply(cistrome_overlap_transcripts,plyranges::find_overlaps,y=genes)
cistrome_overlap_gene_names<-lapply(cistrome_overlap_genes,function(x){unique(unlist(x$SYMBOL))})
total_genes<-unique(unlist(cistrome_overlap_gene_names))
scenic_cistrome_overlap<-scenic_output_tfs[scenic_output_tfs %in% total_genes]
paper_nodes[paper_nodes %in% scenic_cistrome_overlap]
cistrome_overlap_gene_names<-lapply(cistrome_overlap_gene_names, function(x){x[x %in% scenic_output_tfs]})

#Add cistrome filter to interactions_summary
cistrome_confirmed_interactions<-c()
for (z in names(cistrome_overlap_gene_names)){
  for(y in cistrome_overlap_gene_names[[z]]){
    cistrome_confirmed_interactions<-append(cistrome_confirmed_interactions,paste0(z,"->",y))
  }
}
our_cistrome_confirmed_interactions<-cistrome_confirmed_interactions[cistrome_confirmed_interactions %in% all_unique_interactions]
interactions_summary["cistrome_filter"]<-F
interactions_summary[which(all_unique_interactions %in% our_cistrome_confirmed_interactions),"cistrome_filter"]<-T

#Dataframe for interactions that pass cistrome filter
cistrome_summary<-interactions_summary[which(interactions_summary$cistrome_filter==T),]
cistrome_summary_nodes<-unique(c(unique(cistrome_summary$TF),unique(cistrome_summary$target)))

#Dataframe for interactions that pass frequency and cistrome filter
frequency_cistrome_summary<-interactions_summary[which(interactions_summary$cistrome_filter==T &interactions_summary$frequency_filter==T),]
frequency_cistrome_summary_nodes<-unique(c(unique(frequency_cistrome_summary$target),unique(frequency_cistrome_summary$TF)))
```

#Plot interactions from frequency filter marking the ones confirmed by cistrome   
```{r}
#Select dataframe for plotting and plot it
frequency_interactions_plot<-interactions_summary[which(interactions_summary$frequency_filter==T),]
frequency_interactions_plot<-frequency_interactions_plot[,c(1,2,5)]
vertices.df <- data.frame(genes=unique(c(frequency_interactions_plot$target, frequency_interactions_plot$TF)),cistrome=0)
vertices.df["cistrome"]<-as.numeric(vertices.df$genes %in% frequency_cistrome_summary_nodes)

## Importing to igraph
g <- graph_from_data_frame(d = frequency_interactions_plot, directed = TRUE, vertices = vertices.df)
V(g)$degree <- degree(g)
#colrs <- c("gray50", "tomato")
#V(g)$color <- colrs[V(g)$cistrome]

## Select vertices with highest degrees
v.degree <- degree(g)
v.sorted <- sort(v.degree, decreasing = TRUE)
v.sorted<-names(which(v.sorted>10))

g.subset <- induced_subgraph(g, v = v.sorted)
l <- layout_with_fr(g.subset)

plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(V(g.subset)$degree/max(V(g.subset)$degree)*15),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.3),
     edge.width=0.5,
     vertex.frame.color='white')

pdf(paste0(analysis_directory,'/figures/frequency_interactions_plot.pdf'),
     width=15,
     height=12)
plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(V(g.subset)$degree/max(V(g.subset)$degree)*18),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.5),
     edge.width=0.5,
     vertex.frame.color='white')
dev.off()
```


#Multiple amount of peaks
```{r eval=FALSE,echo=FALSE}
#Change peak format
change_peak_format<-function(peak){
  y<-peak[,c(1,2,3,6)]
  new_names<-c("chr","start","end","strand")
  setNames(y,new_names)
}
extend_peaks<-function(peak, e){
  peak<-mutate(peak,start=start-e)
  peak<-mutate(peak,end=end+e)
}

#Output of this loop: Granges object of the extended TF ranges overlap with gene regeions. It contains a metacolumn with gene names which we etract in further loops
peaks_amount<-c(100,250,500,1000,2500,5000,10000)
peak_extensions<-c(0,1000,5000,10000,50000,100000)
cistrome_best_peaks_options<-vector("list",length(peaks_amount))
names(cistrome_best_peaks_options)<-peaks_amount
for (z in peaks_amount){
  copy<-cistrome_blood_files
  for (y in names(copy)){
    best_peaks<-unique(head(sort(copy[[y]]$V5, decreasing=T),z))
    keep<-c()
    for (x in best_peaks){
      keep<-append(keep,which(copy[[y]]$V5==x))
    }
    copy[[y]]<-copy[[y]][keep,]
  }
  copy<-lapply(copy,change_peak_format)
  extension_options<-vector("list",length(peak_extensions))
  names(extension_options)<-peak_extensions
  for(e in peak_extensions){
    extension_options[[as.character(e)]]<-lapply(copy,extend_peaks,e=e)
    for (h in names(extension_options)){
      for(g in names(extension_options[[h]])){
        for (l in seq_along(extension_options[[h]][[g]]$start)){
          if(extension_options[[h]][[g]]$start[l]<0){
            extension_options[[h]][[g]][l,2]<-0
          }
        }
      }
    }
    for (v in names(extension_options)){
      for (j in names(extension_options[[v]])){
        extension_options[[v]][[j]]<-makeGRangesFromDataFrame(extension_options[[v]][[j]])
      }
      extension_options[[v]]<-lapply(extension_options[[v]], GenomicRanges::intersect, y=transcripts, ignore.strand=T)
      extension_options[[v]]<-lapply(extension_options[[v]],plyranges::find_overlaps,y=genes)
    }
  }
  cistrome_best_peaks_options[[as.character(z)]]<-extension_options
}

#Back up mid results
save1<-cistrome_best_peaks_options
cistrome_best_peaks_options<-save1

#Extract metacolumn with gene names
for (x in names(cistrome_best_peaks_options)){
  for (y in names(cistrome_best_peaks_options[[x]])){
    cistrome_best_peaks_options[[x]][[y]]<-lapply(cistrome_best_peaks_options[[x]][[y]],function(h){unique(unlist(h$SYMBOL))})
  }
}

#Create 3 output lists about nodes
total_genes_options<-cistrome_best_peaks_options
scenic_cistrome_overlap_options<-cistrome_best_peaks_options
scenic_cistrome_paper_overlap_options<-cistrome_best_peaks_options
for (x in names(cistrome_best_peaks_options)){
  for (y in names(cistrome_best_peaks_options[[x]])){
    total_genes_options[[x]][[y]]<-unique(unlist(cistrome_best_peaks_options[[x]][[y]]))
    scenic_cistrome_overlap_options[[x]][[y]]<-scenic_output_tfs[scenic_output_tfs %in% total_genes_options[[x]][[y]]]
    scenic_cistrome_paper_overlap_options[[x]][[y]]<-paper_nodes[paper_nodes %in% scenic_cistrome_overlap_options[[x]][[y]]]
  }
}

#See how many interactions are confirmed
for (x in names(cistrome_best_peaks_options)){
  for (y in names(cistrome_best_peaks_options[[x]])){
    cistrome_best_peaks_options[[x]][[y]]<-lapply(cistrome_best_peaks_options[[x]][[y]], function(x){x[x %in% scenic_output_tfs]})
    cistrome_confirmed_interactions<-c()
    for (z in names(cistrome_best_peaks_options[[x]][[y]])){
      for(d in cistrome_best_peaks_options[[x]][[y]][[z]]){
        cistrome_confirmed_interactions<-append(cistrome_confirmed_interactions,paste0(z,"->",d))
      }
    }
    cistrome_best_peaks_options[[x]][[y]]<-cistrome_confirmed_interactions[cistrome_confirmed_interactions %in% all_unique_interactions]
  }
}

#Summarize everything in one list
summary_peaks_options<-cistrome_best_peaks_options
tot_genes<-list()
scenic_cistrome<-list()
scenic_cistrome_paper<-list()
scenic_cistrome_interactions<-list()
categories<-list(tot_genes,scenic_cistrome,scenic_cistrome_paper,scenic_cistrome_interactions)
names(categories)<-c("tot_genes","scenic_cistrome","scenic_cistrome_paper","scenic_cistrome_interactions")
for (x in names(summary_peaks_options)){
  for (y in names(summary_peaks_options[[x]])){
    summary_peaks_options[[x]][[y]]<-categories
    summary_peaks_options[[x]][[y]][["tot_genes"]]<-total_genes_options[[x]][[y]]
    summary_peaks_options[[x]][[y]][["scenic_cistrome"]]<-scenic_cistrome_overlap_options[[x]][[y]]
    summary_peaks_options[[x]][[y]][["scenic_cistrome_paper"]]<-scenic_cistrome_paper_overlap_options[[x]][[y]]
    summary_peaks_options[[x]][[y]][["scenic_cistrome_interactions"]]<-cistrome_best_peaks_options[[x]][[y]]
  }
}
```

#Open ATAC-seq data
```{r echo=FALSE, eval=FALSE}
setwd(data_directory)
gunzip("CHaRs_annotated.tsv.gz")
```

#ATAC-seq data
```{r}
#Selecet only targets and TFs from atac_seq file
atac_seq<-read.table(paste0(data_directory,"/CHaRs_annotated.tsv"),sep='\t',header=T)
keep<-c()
for (x in seq(dim(atac_seq)[1])){
  if(atac_seq$genes[x]!=""){
    keep<-append(keep,x)
  }
}
atac_seq<-atac_seq[keep,]
atac_seq_list<-vector("list", dim(atac_seq)[1])
names(atac_seq_list)<-atac_seq$genes
for (x in seq(length(atac_seq_list))){
  
  str<-atac_seq$TF[[x]]
  
  one<-sub(";.*", "", str)
  two<-str_match_all(str, ";\\s*(.*?)\\s*;")[[1]][,2]
  three<-sub(".*;", "", str)
  
  res<-c(one, two, three)
  
  atac_seq_list[[x]]<-res
  
}
atac_seq_list<-split(atac_seq_list,names(atac_seq_list))
atac_seq_list<-lapply(atac_seq_list,unlist)
atac_seq_list<-lapply(atac_seq_list, unique)

#Deal with complex target names
multiple_targets<-atac_seq_list[grep(";", names(atac_seq_list))]
converted_targets<-list()
for (x in names(multiple_targets)){
  one<-sub(";.*", "", x)
  two<-str_match_all(x, ";\\s*(.*?)\\s*;")[[1]][,2]
  three<-sub(".*;", "", x)
  
  res<-c(one, two, three)
  
  for (y in res){
    converted_targets[[y]]<-multiple_targets[[x]]
  }
}
atac_seq_list<-atac_seq_list[-which(names(atac_seq_list) %in% names(multiple_targets))]
atac_seq_list<-c(converted_targets,atac_seq_list)
atac_seq_list<-split(atac_seq_list,names(atac_seq_list))
atac_seq_list<-lapply(atac_seq_list,unlist)
atac_seq_list<-lapply(atac_seq_list, unique)

#Keep only TF->TF interactions
atac_seq_list<-atac_seq_list[which(names(atac_seq_list) %in% scenic_output_tfs)]
for (x in names(atac_seq_list)){
  atac_seq_list[[x]]<-atac_seq_list[[x]][atac_seq_list[[x]] %in% scenic_output_tfs]
}

#Create ATAC-seq interactions
atac_seq_interactions<-c()
for (x in names(atac_seq_list)){
  for(y in atac_seq_list[[x]]){
    atac_seq_interactions<-append(atac_seq_interactions,paste0(y,"->",x))
  }
}

#Add interactions to the interactions_summary table 
interactions_summary["ataq-seq"]<-F
interactions_summary[which(all_unique_interactions %in% atac_seq_interactions),"ataq-seq"]<-T
interactions_summary[interactions_summary$`ataq-seq`==T,]

#Dataframe for interactions that pass ataq_seq filter
ataq_seq_summary<-interactions_summary[which(interactions_summary$`ataq-seq`==T),]

#Dataframe for interactions that pass frequency and ataq_seq filter
frequency_ataq_seq_summary<-interactions_summary[which(interactions_summary$`ataq-seq`==T & interactions_summary$frequency_filter==T),]
frequency_ataq_seq_summary_nodes<-unique(c(unique(frequency_ataq_seq_summary$TF),unique(frequency_ataq_seq_summary$target)))
```

#Select regulons for binarizing their aucell scores
```{r}
#Filter regulons list for TFs that pass frequency filter
frequency_regulons<-vector("list", length(regulons))
names(frequency_regulons)<-names(regulons)
for (x in names(regulons)){
  keep<-names(regulons[[x]])[names(regulons[[x]])%in% frequency_summary_nodes]
  frequency_regulons[[x]]<-regulons[[x]][keep]
}

#Remove the scenic runs list levels and unite all the targets of each TF as one entry
regulon_targets<-vector("list", length(frequency_summary_nodes))
names(regulon_targets)<-frequency_summary_nodes
for (y in frequency_summary_nodes){
  a<-list()
  for (x in names(frequency_regulons)){
    if (sum(y==names(frequency_regulons[[x]]))!=0){
    pos<-which(names(frequency_regulons[[x]])==y)
    a[[x]]<-frequency_regulons[[x]][[pos]]
    }
  }
  regulon_targets[[y]]<-a
}

#Keep only unique interactions that satisfy our frequency criteria
for (x in names(regulon_targets)){
  regulon_targets[[x]]<-sort(table(unlist(regulon_targets[[x]])),decreasing = T)
}

for (x in names(regulon_targets)){
  regulon_targets[[x]]<-names(which((regulon_targets[[x]]>=5)==T))
}

#Remove small regulons: < 15 interactions
remove<-which(lapply(regulon_targets, length)<15)
remove_names<-names(remove)
regulon_targets<-regulon_targets[-remove]
```

#Conduct new aucell for the selected regulons
```{r}
#input_for_single_aucell<-scale(input) #scale each gene's expression
#Select only the cells that have a cell type assigned to it
input_for_single_aucell<-t(input)

setwd(data_directory)
cell_annotations<-read.xlsx("nina_annotations.xlsx")
input_for_single_aucell<-input_for_single_aucell[,cell_annotations$CELLID]

#Run AUCell
expr_matrix <- as(input_for_single_aucell, "dgCMatrix")
cells_rankings<-AUCell_buildRankings(expr_matrix)

cells_AUC <- AUCell_calcAUC(regulon_targets, cells_rankings)
cells_assignment <- AUCell_exploreThresholds(cells_AUC, plotHist=TRUE, assign=TRUE) 
```

#Select thresholds for binarizing
```{r}
#Regulons that have a robust assigned threshold
assigned_regulons<-c("MXI1","PURA", "RORA", "ZNF426", "KLF6", "MLXIP","MXD4","RELA","MAX", "TFDP2","ZNF600", "ETS1", "ZNF217","NR1D2","YY1","ELF2","REST","ELF1","FLI1","SRF")

#Regulons that have a robust threshold, which is not assigned
switched_regulons<-c("ETV3")

#Regulons that don not have a robust threshold: average of all thresholds
average_regulons<-c("CIC","TCF3","CRX","ZNF445","ZNF774","NFIC","CEBPZ")

#Select the thresholds
active_assigned_regulons<-vector("list", length(assigned_regulons))
names(active_assigned_regulons)<-assigned_regulons
for (x in assigned_regulons){
  active_assigned_regulons[[x]]<-cells_assignment[[x]]$assignment
}

active_average_regulons<-vector("list", length(average_regulons))
names(active_average_regulons)<-average_regulons
for (x in average_regulons){
  thr<-mean(cells_assignment[[x]]$aucThr$thresholds[,1])
  active_average_regulons[[x]]<-names(which(getAUC(cells_AUC)[x,]>thr))
}

active_regulons<-c(active_assigned_regulons,active_average_regulons)
```

#Heatmap according to cell types
```{r}
#Get the cell types and corresponding cells
cell_types<-split(cell_annotations,cell_annotations$TYPE)

#Create our new aucell dataframe
single_aucell<-data.frame(matrix(0,ncol=dim(cell_annotations)[1], nrow = length(names(active_regulons))))
rownames(single_aucell)<-names(active_regulons)
colnames(single_aucell)<-cell_annotations[,2]

#Fill the dataframe with values
for(x in names(active_regulons)){
  ones<-which(colnames(single_aucell) %in% active_regulons[[x]])
  single_aucell[x,ones]<-1
}

#Split our dataframe according to the cell types
for (x in names(cell_types)){
  cell_types[[x]]<-single_aucell[,cell_types[[x]]$CELLID]
}

#Make the heatmap
calculate_average_expression<-function(x){
  rowSums(x)/dim(x)[2]
}

cell_types_means<-lapply(cell_types,calculate_average_expression)
heat_map<-data.frame(matrix(nrow=length(names(active_regulons)), ncol=length(cell_types_means)))
colnames(heat_map)<-names(cell_types_means)
rownames(heat_map)<-names(active_regulons)

for(x in seq_along(cell_types_means)){
  heat_map[,x]<-cell_types_means[[x]]
}

heat_map<-heat_map[,c(2,3,1)]

#heatmap(as.matrix(heat_map),Colv = NA, Rowv = NA, scale="none")
#heatmap.2(as.matrix(heat_map),Colv = NA, Rowv = NA, scale="row",trace="none")
```

#Trying with all regulons and their automatically assigned thresholds
```{r}
all_regulons<-names(regulon_targets)

active_assigned_regulons<-vector("list", length(all_regulons))
names(active_assigned_regulons)<-all_regulons
for (x in all_regulons){
  active_assigned_regulons[[x]]<-cells_assignment[[x]]$assignment
}
#Get the cell types and corresponding cells
cell_types<-split(cell_annotations,cell_annotations$TYPE)

#Create our new aucell dataframe
single_aucell<-data.frame(matrix(0,ncol=dim(cell_annotations)[1], nrow = length(names(active_assigned_regulons))))
rownames(single_aucell)<-names(active_assigned_regulons)
colnames(single_aucell)<-cell_annotations[,2]

#Fill the dataframe with values
for(x in names(active_assigned_regulons)){
  ones<-which(colnames(single_aucell) %in% active_assigned_regulons[[x]])
  single_aucell[x,ones]<-1
}

#Split our dataframe according to the cell types
for (x in names(cell_types)){
  cell_types[[x]]<-single_aucell[,cell_types[[x]]$CELLID]
}

#Make the heatmap
calculate_average_expression<-function(x){
  rowSums(x)/dim(x)[2]
}

cell_types_means<-lapply(cell_types,calculate_average_expression)
heat_map<-data.frame(matrix(nrow=length(names(active_assigned_regulons)), ncol=length(cell_types_means)))
colnames(heat_map)<-names(cell_types_means)
rownames(heat_map)<-names(active_assigned_regulons)

for(x in seq_along(cell_types_means)){
  heat_map[,x]<-cell_types_means[[x]]
}

heat_map<-heat_map[,c(2,3,1)]

heatmap(as.matrix(heat_map),Colv = NA, Rowv = NA, scale="none",col = bluered(100))
```

#Trying with all regulons and average of their thresholds
```{r}
all_regulons<-names(regulon_targets)

active_assigned_regulons<-vector("list", length(all_regulons))
names(active_assigned_regulons)<-all_regulons
for (x in all_regulons){
  thr<-mean(cells_assignment[[x]]$aucThr$thresholds[,1])
  active_assigned_regulons[[x]]<-names(which(getAUC(cells_AUC)[x,]>thr))
}

#Get the cell types and corresponding cells
cell_types<-split(cell_annotations,cell_annotations$TYPE)

#Create our new aucell dataframe
single_aucell<-data.frame(matrix(0,ncol=dim(cell_annotations)[1], nrow = length(names(active_assigned_regulons))))
rownames(single_aucell)<-names(active_assigned_regulons)
colnames(single_aucell)<-cell_annotations[,2]

#Fill the dataframe with values
for(x in names(active_assigned_regulons)){
  ones<-which(colnames(single_aucell) %in% active_assigned_regulons[[x]])
  single_aucell[x,ones]<-1
}

#Split our dataframe according to the cell types
for (x in names(cell_types)){
  cell_types[[x]]<-single_aucell[,cell_types[[x]]$CELLID]
}

#Make the heatmap
calculate_average_expression<-function(x){
  rowSums(x)/dim(x)[2]
}

cell_types_means<-lapply(cell_types,calculate_average_expression)
heat_map<-data.frame(matrix(nrow=length(names(active_assigned_regulons)), ncol=length(cell_types_means)))
colnames(heat_map)<-names(cell_types_means)
rownames(heat_map)<-names(active_assigned_regulons)

for(x in seq_along(cell_types_means)){
  heat_map[,x]<-cell_types_means[[x]]
}

heat_map<-heat_map[,c(2,3,1)]

heatmap(as.matrix(heat_map),Colv = NA, Rowv = NA, scale="none", col = bluered(100))
```
#Another approach for Aucell binarizing
```{r}
#Open all Aucell files from Scenic
aucell_files<-vector("list",length=n)
names(aucell_files)<-seq(n)
for (x in seq(n)){
  aucell_files[[as.character(x)]]<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome/run_",as.character(x),"/aucell.csv"),header=T,row.names = 1)
  aucell_files[[as.character(x)]]
}

#Remove "..." from colnames
for (x in names(aucell_files)){
  colnames(aucell_files[[x]])<-gsub(colnames(aucell_files[[x]]),pattern="[...]",replacement="")
}

#Keep only relevant columns and rows
for (x in names(aucell_files)){
  aucell_files[[x]]<-aucell_files[[x]][rownames(aucell_files[[x]]) %in% cell_annotations$CELLID,colnames(aucell_files[[x]]) %in% frequency_summary_nodes]
}

#Change fromat from dataframes to a nested list
aucell_files_list<-vector("list", length(aucell_files))
names(aucell_files_list)<-names(aucell_files)
for (x in names(aucell_files)){
  sublist<-vector("list",length = dim(aucell_files[[x]])[2])
  names(sublist)<-colnames(aucell_files[[x]])
  for(y in colnames(aucell_files[[x]])){
    sublist[[y]]<-aucell_files[[x]][,y]
  }
  aucell_files_list[[x]]<-sublist
}

#Remove the scenic runs list levels and unite all genes as one entry
aucell_files_list2<-vector("list", length(frequency_summary_nodes))
names(aucell_files_list2)<-frequency_summary_nodes
for (y in frequency_summary_nodes){
  a<-list()
  for (x in names(aucell_files_list)){
    if (sum(y==names(aucell_files_list[[x]]))!=0){
    pos<-which(names(aucell_files_list[[x]])==y)
    a[[x]]<-aucell_files_list[[x]][[pos]]
    }
  }
  aucell_files_list2[[y]]<-a
}

#Convert entry for each TF into a dataframe
aucell_files_list2<-lapply(aucell_files_list2, as.data.frame)
for (x in names(aucell_files_list2)){
  rownames(aucell_files_list2[[x]])<-cell_annotations$CELLID
}

#Average the score for each gene NORMALIZE HERE???
average_gene_aucell<-vector("list", length(aucell_files_list2))
names(average_gene_aucell)<-names(aucell_files_list2)
for (x in names(aucell_files_list2)){
  average_gene_aucell[[x]]<-rowMeans(aucell_files_list2[[x]])
}

single_aucell<-as.data.frame(average_gene_aucell)

#Plot histograms for each gene
for (x in colnames(single_aucell)){
  hist(single_aucell[,x], main = x, breaks = 50)
}

#Plot histogram for one specific gene
for (x in colnames(aucell_files_list2[["ETS1"]])){
  hist(aucell_files_list2[["ETS1"]][,x], breaks = 50)
}
```

#Make heatmap without binirizing Aucell scores but taking their average (previous chunck)
```{r}
#Get the cell types and corresponding cells
cell_types<-split(cell_annotations,cell_annotations$TYPE)

#Subset and average single_aucell according to the cell type
for (x in names(cell_types)){
  cells<-cell_types[[x]]$CELLID
  cell_types[[x]]<-single_aucell[cells,]
}

cell_types<-lapply(cell_types, colMeans)

#Make a heatmap
heat_map<-as.data.frame(cell_types)
heat_map<-heat_map[,c(2,3,1)]

heatmap(as.matrix(heat_map),Colv = NA, Rowv = NA, scale="row", col = bluered(100))
```

