---
title: "Output_full_genome_new_workflow"
author: "Ilya"
date: "10/06/2022"
output: html_document
---
  
#Download packages
```{r}
#install.packages("LaplacesDemon")

#install.packages(mousetrap)

#install.packages("https://cran.r-project.org/src/contrib/Archive/randomForest/randomForest_4.6-14.tar.gz", repos=NULL, type="source")

#install.packages("RColorBrewer")

#install.packages("igraph")

#install.packages("dplyr")

#install.packages("openxlsx")

#install.packages("gplots")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("GenomicRanges")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("Homo.sapiens")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("plyranges")

#install.packages("ellipsis")
#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("AUCell")

#if (!require("BiocManager", quietly = TRUE))
#install.packages("BiocManager")
#BiocManager::install("GSEABase")

#if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#BiocManager::install("GEOquery")

#if (!require("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")

#BiocManager::install("ComplexHeatmap")
```

#Load packages
```{r}
update.packages("ellipsis")
#library(dplyr)
update.packages("htmltools")
library(GenomicRanges)
library(GenomicFeatures)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(Homo.sapiens)
library(plyranges)
library(AUCell)
library(GSEABase)
library(GEOquery)
library(openxlsx)
library(stringr)
library(gplots)
library(igraph)
library(RColorBrewer)
library(ComplexHeatmap)
library(randomForest)
library(mousetrap)
library(LaplacesDemon)
library(devtools)
``` 

#Direcrories
```{r}
main_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/scr"
data_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/data"
analysis_directory<-"/media/ag-cherrmann/ischneider/GRNTcellExh/analysis"
```

#Edit the input file for the 50 Scenic runs
```{r eval=FALSE, echo=FALSE}
#Read input table
raw_input<-read.csv("/media/ag-cherrmann/cramirez/tcd8ExscSeq/data/maike2020/nina_thimme_raw_counts.csv",header=T, row.names=1)

#Read cell annotations
setwd(data_directory)
cell_annotations<-read.xlsx("nina_annotations.xlsx")

#Remove RNA genes
raw_input<-t(as.data.frame(raw_input))
raw_input<-raw_input[,17:dim(raw_input)[2]]

#Remove chromosme tags and duplicates
genes<-gsub("\\_.*","",colnames(raw_input))
remove<-which(duplicated(genes))
genes<-genes[-remove] 
raw_input<-raw_input[,-remove]
colnames(raw_input)<-genes
raw_input<-as.data.frame(raw_input)

#Bolouri paper nodes with appropriate nomenclature substitutions
paper_nodes<-c("HNF1A","TNFSF9","TNFRSF9","IL12RB1","IL12RB2","IL21R","FCER1G","CD3","CD8","CD28","PIK3K","EZH2","PRC2","IL2R","RAS","MAPK1","JUN","FOS","BATF","AKT1", "AKT2", "AKT3","FOXO1","EGR2","EGR3","BACH2","ID3","ID2","NFKB1","MTOR","IRF4","TCF3","NFATC2","PPARGC1A","BCL6","PRDM1","NFATC1","CXCR5","TBX21","ZEB2","LAG3","PDCD1","HIF1A","KLRG1","PPARA","CTLA4","HAVCR2","BTLA","NR4A1","CD160","TIGIT","IL15RA","CD244","CD2B4","MYC","RUNX3","EOMES","FAS","FASLG","GZMA","GZMB","PRF1","IFNG")
paper_substitutions<-list("HNF1A","TNFRSF9",c("IL12RB1","IL12RB2"),c("AKT1","AKT2","AKT3"),"TCF3","PRDM1","TBX21","PDCD1","PPARA","TNFSF9","FCER1G","MAPK1","PPARGC1A","IL15RA")
names(paper_substitutions)<-c("TCF1","41BB","IL12R","AKT","E2A","BLIMP1","TBET","PD1","PPAR","CD137L","CD3","MAPK","PGC1A","IL15R")

#Keep only cells with annotations
raw_input<-raw_input[cell_annotations$CELLID,]

#Keep only the genes that meet the filtering criteria
input<-raw_input[,names(which(colSums(raw_input)>2*0.01*nrow(raw_input))==T)]

#Include all paper nodes into the input table
paper_nodes_in_input<-paper_nodes[paper_nodes %in% colnames(input)]
paper_nodes_left_out<-paper_nodes[! paper_nodes %in% colnames(input)]
input<-cbind(input,raw_input[,which(colnames(raw_input) %in% paper_nodes_left_out)])
```

#Export the input table
```{r eval=FALSE, echo=FALSE}
setwd("/media/ag-cherrmann/ischneider/GRNTcellExh/data/SCENIC50/Input")
write.table(input, file='scenic_input_full_genome.tsv', quote=FALSE, sep='\t', row.names = T)
#Code for bash to iterate Scenic 50 times
#bash /media/ag-cherrmann/ischneider/GRNTcellExh/scr/Scenic.txt

#Save the table
setwd(analysis_directory)
write.table(input, file='scenic_input_full_genome.tsv', quote=FALSE, sep='\t', row.names = T)
```

#Open input table
```{r}
input<-read.table(paste0("/media/ag-cherrmann/ischneider/GRNTcellExh/data/SCENIC50/Input","/scenic_input_full_genome.tsv"),sep='\t',header=T)

#Bolouri paper nodes with appropriate nomenclature substitutions
paper_nodes<-c("HNF1A","TNFSF9","TNFRSF9","IL12RB1","IL12RB2","IL21R","FCER1G","CD3","CD8","CD28","PIK3K","EZH2","PRC2","IL2R","RAS","MAPK1","JUN","FOS","BATF","AKT1", "AKT2", "AKT3","FOXO1","EGR2","EGR3","BACH2","ID3","ID2","NFKB1","MTOR","IRF4","TCF3","NFATC2","PPARGC1A","BCL6","PRDM1","NFATC1","CXCR5","TBX21","ZEB2","LAG3","PDCD1","HIF1A","KLRG1","PPARA","CTLA4","HAVCR2","BTLA","NR4A1","CD160","TIGIT","IL15RA","CD244","CD2B4","MYC","RUNX3","EOMES","FAS","FASLG","GZMA","GZMB","PRF1","IFNG")
paper_substitutions<-list("HNF1A","TNFRSF9",c("IL12RB1","IL12RB2"),c("AKT1","AKT2","AKT3"),"TCF3","PRDM1","TBX21","PDCD1","PPARA","TNFSF9","FCER1G","MAPK1","PPARGC1A","IL15RA")
names(paper_substitutions)<-c("TCF1","41BB","IL12R","AKT","E2A","BLIMP1","TBET","PD1","PPAR","CD137L","CD3","MAPK","PGC1A","IL15R")

#Read cell annotations
setwd(data_directory)
cell_annotations<-read.xlsx("nina_annotations.xlsx")
cell_types<-split(cell_annotations,cell_annotations$TYPE)
cell_types<-cell_types[c(2,3,1)]

cell_types_cell_ids<-cell_types
for(x in names(cell_types)){
  cell_types_cell_ids[[x]]<-cell_types[[x]]$CELLID
}
```

#Select all TFs from aucell files
```{r}
#Number of scenic runs
n=50

#Open all aucell files and keep TFs from them
aucell_tfs<-vector("list",length=n)
names(aucell_tfs)<-seq(n)
for (x in seq(n)){
  aucell<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome_new_workflow/run_",as.character(x),"/aucell.csv"),header=T,row.names = 1)
  aucell_tfs[[as.character(x)]]<-colnames(aucell)
}

aucell_tfs<-lapply(aucell_tfs, gsub, pattern="[...]",replacement="")
scenic_output_tfs<-unique(unlist(aucell_tfs))
```

#Get targets for TFs from reg files
```{r}
#Get target column from each reg file
reg_targets<-vector("list",length=n)
names(reg_targets)<-seq(n)
for (x in seq(n)){
  reg<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome_new_workflow/run_",as.character(x),"/reg.csv"),header=T)
  reg_targets[[as.character(x)]]<-reg
}

change_reg_format<-function(r){
  names<-c(r[2,1:2],r[1,3:dim(r)[2]])
  y<-setNames(r,names)
  y<-y[-c(1,2),]
}

reg_targets<-lapply(reg_targets,change_reg_format)
for (x in names(reg_targets)){
  reg_targets[[x]]<-split(reg_targets[[x]],reg_targets[[x]]$TF)
}

for (x in names(reg_targets)){
  for (y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-reg_targets[[x]][[y]]$TargetGenes
  }
}

#Extract target names
extract_targets <- function(x){
  targets <- regmatches(x, gregexpr("'[^']*'", x))[[1]] 
  gsub("'", '', targets)
}

extract_all_unique_targets<-function(obj){
  unique(extract_targets(paste0(c(obj),collapse = "")))
}

for (x in names(reg_targets)){
  for(y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-extract_all_unique_targets(reg_targets[[x]][[y]])
  }
}

regulons<-reg_targets
for (x in names(reg_targets)){
  for(y in names(reg_targets[[x]])){
    reg_targets[[x]][[y]]<-reg_targets[[x]][[y]][reg_targets[[x]][[y]] %in% scenic_output_tfs] #we keep not only TF->TF interactions
  }
}

#Remove self regulation
for (y in names(reg_targets)){
  for (x in scenic_output_tfs){
    lookup<-x==reg_targets[[y]][[x]]
    pos<-which(lookup==T)
    if(sum(lookup)!=0){
      reg_targets[[y]][[x]]<-reg_targets[[y]][[x]][-c(pos)]
    }
  }
} 

#Remove TFs with no targets
for (x in names(reg_targets)){
  remove<-which(lapply(reg_targets[[x]], length)==0)
  reg_targets[[x]]<-reg_targets[[x]][-remove]
}

reg_tfs<-c()
for (x in names(reg_targets)){
  reg_tfs<-append(reg_tfs,names(reg_targets[[x]]))
}
reg_tfs<-unique(reg_tfs)
```

#Create a file with all the interactions that we want to keep
```{r}
#Put all interactions in dataframe form
all_interactions<-c()
for (z in names(reg_targets)){
  for(x in names(reg_targets[[z]])){
    for(y in reg_targets[[z]][[x]]){
      all_interactions<-append(all_interactions,paste0(x,"->",y))
    }
  }
}

frequency<-(table(all_interactions))
all_unique_interactions<-names(frequency)
interactions_summary<-as.data.frame(matrix(ncol=3,nrow=length(unlist(all_unique_interactions))))
colnames(interactions_summary)<-c("TF", "target","frequency")
interactions_summary$frequency<-as.numeric(frequency)
interactions_summary$TF<-sub("->.*", "", all_unique_interactions)
interactions_summary$target<-sub(".*->", "", all_unique_interactions)

#Add frequency filter
frequency_filter=40
for(x in seq(dim(interactions_summary)[1])){
  f<-interactions_summary$frequency[x]
  if(f>=frequency_filter){
    interactions_summary[x,"frequency_filter"]<-T
  }else{
    interactions_summary[x,"frequency_filter"]<-F
  }
}

#Dataframe for interactions that pass frequency filter
frequency_summary<-interactions_summary[which(interactions_summary$frequency_filter==T),]
frequency_summary_nodes<-unique(c(unique(frequency_summary$target),unique(frequency_summary$TF)))
```

#Select best peaks for cistrome
```{r eval=FALSE, echo=FALSE}
#Work with cistrome description file
setwd(data_directory)
cistrome_description<-read.delim("human_factor_full_QC.txt")
cistrome_blood<-cistrome_description[cistrome_description$Tissue_type=="Blood",]

#File 38912 is empty and gives us an error in the loop so we remove it
cistrome_blood<-cistrome_blood[cistrome_blood$DCid!=38912,]
cistrome_blood_file_names<-cistrome_blood$DCid

#Open corresponding files
cistrome_blood_files<-vector("list", length(cistrome_blood_file_names))
names(cistrome_blood_files)<-cistrome_blood_file_names
for (x in cistrome_blood_file_names){
  cistrome_blood_files[[as.character(x)]]<-as.data.frame(read.table(paste0(data_directory,"/human_factor/",as.character(x),"_sort_peaks.narrowPeak.bed"),header = FALSE, sep="\t",stringsAsFactors=FALSE, quote=""))
}

#Keep only TFs that appear in scenic output
names(cistrome_blood_files)<-cistrome_blood$Factor
cistrome_blood_files<-cistrome_blood_files[names(cistrome_blood_files) %in% scenic_output_tfs]

#Split the list into groups according to a TF
cistrome_blood_files<-split(cistrome_blood_files,names(cistrome_blood_files))
cistrome_blood_files<-lapply(cistrome_blood_files, dplyr::bind_rows)

#Select top 10000 peaks for each TF
cistrome_best_peaks<-cistrome_blood_files
for (y in names(cistrome_best_peaks)){
  best_peaks<-unique(head(sort(cistrome_best_peaks[[y]]$V5, decreasing=T),1000))
  keep<-c()
  for (x in best_peaks){
    keep<-append(keep,which(cistrome_best_peaks[[y]]$V5==x))
  }
  cistrome_best_peaks[[y]]<-cistrome_best_peaks[[y]][keep,]
}

#Export cistrome_best_peaks
for (x in names(cistrome_best_peaks)){
  write.csv(cistrome_best_peaks[[x]],paste0(analysis_directory,"/","cistrome_best_peaks/",x,".csv"), row.names = F)
}
```

#Import cistrome_best_peaks
```{r}
best_peaks_file_names<-list.files(paste0(analysis_directory,"/","cistrome_best_peaks"))
cistrome_best_peaks<-list()
for (x in seq_along(best_peaks_file_names)){
  cistrome_best_peaks[[x]]<-read.csv(paste0(analysis_directory,"/","cistrome_best_peaks/",best_peaks_file_names[x]))
}
names(cistrome_best_peaks)<-sub(".csv*.", "", best_peaks_file_names)
```

#Prepare Cistrome peaks for intersection with reference genome
```{r}
#Change peak format
change_peak_format<-function(peak){
  y<-peak[,c(1,2,3,6)]
  new_names<-c("chr","start","end","strand")
  setNames(y,new_names)
}
cistrome_best_peaks<-lapply(cistrome_best_peaks,change_peak_format)

#Extend the peaks by 10 kb in both directions
extension=10000
extend_peaks<-function(peak, e){
  peak<-mutate(peak,start=start-e)
  peak<-mutate(peak,end=end+e)
}
cistrome_extended_peaks<-lapply(cistrome_best_peaks,extend_peaks,e=extension)
for(y in names(cistrome_extended_peaks)){
  for (x in seq_along(cistrome_extended_peaks[[y]]$start)){
    if(cistrome_extended_peaks[[y]]$start[x]<0){
      cistrome_extended_peaks[[y]][x,2]<-0
    }
  }
}
cistrome_granges_peaks<-cistrome_extended_peaks

#Make Granges objects
for (x in names(cistrome_extended_peaks)){
  cistrome_granges_peaks[[x]]<-makeGRangesFromDataFrame(cistrome_extended_peaks[[x]])
}
```

#Overlap peaks with reference genome
```{r}
#Get reference transcripts
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
transcripts <- GenomicFeatures::genes(txdb)

#Get reference genes
TxDb(Homo.sapiens) <- txdb
genes_list <- transcriptsBy(Homo.sapiens, columns = "SYMBOL")
genes <- unlist(genes_list)
cistrome_overlap_transcripts<-lapply(cistrome_granges_peaks, GenomicRanges::intersect, y=transcripts, ignore.strand=T)

#Create overlap and obtain gene names
cistrome_overlap_genes<-lapply(cistrome_overlap_transcripts,plyranges::find_overlaps,y=genes)
cistrome_overlap_gene_names<-lapply(cistrome_overlap_genes,function(x){unique(unlist(x$SYMBOL))})
total_genes<-unique(unlist(cistrome_overlap_gene_names))
scenic_cistrome_overlap<-scenic_output_tfs[scenic_output_tfs %in% total_genes]
paper_nodes[paper_nodes %in% scenic_cistrome_overlap]
cistrome_overlap_gene_names<-lapply(cistrome_overlap_gene_names, function(x){x[x %in% scenic_output_tfs]})

#Add cistrome filter to interactions_summary
cistrome_confirmed_interactions<-c()
for (z in names(cistrome_overlap_gene_names)){
  for(y in cistrome_overlap_gene_names[[z]]){
    cistrome_confirmed_interactions<-append(cistrome_confirmed_interactions,paste0(z,"->",y))
  }
}
our_cistrome_confirmed_interactions<-cistrome_confirmed_interactions[cistrome_confirmed_interactions %in% all_unique_interactions]
interactions_summary["cistrome_filter"]<-F
interactions_summary[which(all_unique_interactions %in% our_cistrome_confirmed_interactions),"cistrome_filter"]<-T

#Dataframe for interactions that pass cistrome filter
cistrome_summary<-interactions_summary[which(interactions_summary$cistrome_filter==T),]
cistrome_summary_nodes<-unique(c(unique(cistrome_summary$TF),unique(cistrome_summary$target)))

#Dataframe for interactions that pass frequency and cistrome filter
frequency_cistrome_summary<-interactions_summary[which(interactions_summary$cistrome_filter==T &interactions_summary$frequency_filter==T),]
frequency_cistrome_summary_nodes<-unique(c(unique(frequency_cistrome_summary$target),unique(frequency_cistrome_summary$TF)))
```

#Plot interactions from frequency filter marking the ones confirmed by cistrome
```{r}
#Select dataframe for plotting and plot it
frequency_interactions_plot<-interactions_summary[which(interactions_summary$frequency_filter==T),]
frequency_interactions_plot<-frequency_interactions_plot[,c(1,2,5)]
vertices.df <- data.frame(genes=unique(c(frequency_interactions_plot$target, frequency_interactions_plot$TF)),cistrome=0)
vertices.df["cistrome"]<-as.numeric(vertices.df$genes %in% frequency_cistrome_summary_nodes)

## Importing to igraph
g <- graph_from_data_frame(d = frequency_interactions_plot, directed = TRUE, vertices = vertices.df)
V(g)$degree <- degree(g)
#colrs <- c("gray50", "tomato")
#V(g)$color <- colrs[V(g)$cistrome]

## Select vertices with highest degrees
v.degree <- degree(g)
v.sorted <- sort(v.degree, decreasing = TRUE)
v.sorted<-names(which(v.sorted>5))

g.subset <- induced_subgraph(g, v = v.sorted)
l <- layout_with_fr(g.subset)

plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(V(g.subset)$degree/max(V(g.subset)$degree)*15),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.3),
     edge.width=0.5,
     vertex.frame.color='white')

pdf(paste0(analysis_directory,'/figures/frequency_interactions_plot.pdf'),
     width=15,
     height=12)
plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(V(g.subset)$degree/max(V(g.subset)$degree)*18),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.5),
     edge.width=0.5,
     vertex.frame.color='white')
dev.off()
``` 

#ATAC-seq data
```{r}
#Selecet only targets and TFs from atac_seq file
atac_seq<-read.table(paste0(data_directory,"/CHaRs_annotated.tsv"),sep='\t',header=T)
keep<-c()
for (x in seq(dim(atac_seq)[1])){
  if(atac_seq$genes[x]!=""){
    keep<-append(keep,x)
  }
}
atac_seq<-atac_seq[keep,]
atac_seq_list<-vector("list", dim(atac_seq)[1])
names(atac_seq_list)<-atac_seq$genes
for (x in seq(length(atac_seq_list))){
  
  str<-atac_seq$TF[[x]]
  
  one<-sub(";.*", "", str)
  two<-str_match_all(str, ";\\s*(.*?)\\s*;")[[1]][,2]
  three<-sub(".*;", "", str)
  
  res<-c(one, two, three)
  
  atac_seq_list[[x]]<-res
  
}
atac_seq_list<-split(atac_seq_list,names(atac_seq_list))
atac_seq_list<-lapply(atac_seq_list,unlist)
atac_seq_list<-lapply(atac_seq_list, unique)

#Deal with complex target names
multiple_targets<-atac_seq_list[grep(";", names(atac_seq_list))]
converted_targets<-list()
for (x in names(multiple_targets)){
  one<-sub(";.*", "", x)
  two<-str_match_all(x, ";\\s*(.*?)\\s*;")[[1]][,2]
  three<-sub(".*;", "", x)
  
  res<-c(one, two, three)
  
  for (y in res){
    converted_targets[[y]]<-multiple_targets[[x]]
  }
}
atac_seq_list<-atac_seq_list[-which(names(atac_seq_list) %in% names(multiple_targets))]
atac_seq_list<-c(converted_targets,atac_seq_list)
atac_seq_list<-split(atac_seq_list,names(atac_seq_list))
atac_seq_list<-lapply(atac_seq_list,unlist)
atac_seq_list<-lapply(atac_seq_list, unique)

#Keep only TF->TF interactions
atac_seq_list<-atac_seq_list[which(names(atac_seq_list) %in% scenic_output_tfs)]
for (x in names(atac_seq_list)){
  atac_seq_list[[x]]<-atac_seq_list[[x]][atac_seq_list[[x]] %in% scenic_output_tfs]
}

#Create ATAC-seq interactions
atac_seq_interactions<-c()
for (x in names(atac_seq_list)){
  for(y in atac_seq_list[[x]]){
    atac_seq_interactions<-append(atac_seq_interactions,paste0(y,"->",x))
  }
}

#Add interactions to the interactions_summary table 
interactions_summary["ataq-seq"]<-F
interactions_summary[which(all_unique_interactions %in% atac_seq_interactions),"ataq-seq"]<-T
interactions_summary[interactions_summary$`ataq-seq`==T,]

#Dataframe for interactions that pass ataq_seq filter
ataq_seq_summary<-interactions_summary[which(interactions_summary$`ataq-seq`==T),]

#Dataframe for interactions that pass frequency and ataq_seq filter
frequency_ataq_seq_summary<-interactions_summary[which(interactions_summary$`ataq-seq`==T & interactions_summary$frequency_filter==T),]
frequency_ataq_seq_summary_nodes<-unique(c(unique(frequency_ataq_seq_summary$TF),unique(frequency_ataq_seq_summary$target)))
```

#Select regulons for binarizing their aucell scores
```{r}
#Filter regulons list for TFs that pass frequency filter
frequency_regulons<-vector("list", length(regulons))
names(frequency_regulons)<-names(regulons)
for (x in names(regulons)){
  keep<-names(regulons[[x]])[names(regulons[[x]])%in% frequency_summary_nodes]
  frequency_regulons[[x]]<-regulons[[x]][keep]
}

#Remove the scenic runs list levels and unite all the targets of each TF as one entry
regulon_targets<-vector("list", length(frequency_summary_nodes))
names(regulon_targets)<-frequency_summary_nodes
for (y in frequency_summary_nodes){
  a<-list()
  for (x in names(frequency_regulons)){
    if (sum(y==names(frequency_regulons[[x]]))!=0){
    pos<-which(names(frequency_regulons[[x]])==y)
    a[[x]]<-frequency_regulons[[x]][[pos]]
    }
  }
  regulon_targets[[y]]<-a
}
```

#Conduct new aucell for the selected regulons
```{r}
#Keep only unique interactions that satisfy our frequency criteria
for (x in names(regulon_targets)){
  regulon_targets[[x]]<-sort(table(unlist(regulon_targets[[x]])),decreasing = T)
}

for (x in names(regulon_targets)){
  regulon_targets[[x]]<-names(which((regulon_targets[[x]]>=1)==T))
}

#Remove small regulons: < 15 interactions
remove<-which(lapply(regulon_targets, length)<15)
remove_names<-names(remove)
regulon_targets<-regulon_targets[-remove]

#Select only the cells that have a cell type assigned to it
input_for_single_aucell<-t(input)
input_for_single_aucell<-input_for_single_aucell[,cell_annotations$CELLID]

#Run AUCell
expr_matrix <- as(input_for_single_aucell, "dgCMatrix")
cells_rankings<-AUCell_buildRankings(expr_matrix)

cells_AUC <- AUCell_calcAUC(regulon_targets, cells_rankings)
cells_assignment <- AUCell_exploreThresholds(cells_AUC, plotHist=TRUE, assign=TRUE) 
```

#Make a heatmap to represent the aucell scores
```{r}
#Get AUCell matrix
aucell_scores<-as.data.frame(getAUC(cells_AUC))

#Get cell ids grouped accroding to phenotype in the AUCell matrix
cell_ids_ordered<-c()
for (x in names(cell_types)){
  cell_ids_ordered<-append(cell_ids_ordered,cell_types[[x]]$CELLID)
}

aucell_scores<-aucell_scores[,cell_ids_ordered]
aucell_scores<-aucell_scores[sort(rownames(aucell_scores)),]

#Make a heatmap
#heatmap(as.matrix(aucell_scores),Colv = NA, Rowv = NA, scale="none",col = bluered(100))

pdf(paste0(analysis_directory,'/figures/new_aucell_not_norm.pdf'),
     width=15,
     height=40)

Heatmap(aucell_scores,cluster_rows = F,cluster_columns = F, column_labels = rep("",length(colnames(aucell_scores))), column_split = rep(names(cell_types), times = c(dim(cell_types[[1]])[1],dim(cell_types[[2]])[1],dim(cell_types[[3]])[1])))
dev.off()

aucell_scores_norm<-t(scale(t(aucell_scores)))

pdf(paste0(analysis_directory,'/figures/new_aucell_norm.pdf'),
     width=15,
     height=40)

Heatmap(aucell_scores_norm,cluster_rows = F,cluster_columns = F, column_labels = rep("",length(colnames(aucell_scores))), column_split = rep(names(cell_types), times = c(dim(cell_types[[1]])[1],dim(cell_types[[2]])[1],dim(cell_types[[3]])[1])))
dev.off()

#Test distributions of aucell scores for bimodality
sum(apply(aucell_scores, 1, is.bimodal))/dim(aucell_scores)[1]
sum(apply(aucell_scores, 1, bimodality_coefficient)>0.555)/dim(aucell_scores)[1]

#Distributions of aucell scores within each cell_type
aucell_scores_norm_cell_types<-cell_types_cell_ids
for (x in names(cell_types_cell_ids)){
  aucell_scores_norm_cell_types[[x]]<-aucell_scores_norm[,cell_types_cell_ids[[x]]]
}

aucell_scores_norm_cell_types<-lapply(aucell_scores_norm_cell_types, rowMeans)

for (x in aucell_scores_norm_cell_types){
  hist(x, breaks=50)
}
```

#Random Forest to identify TFs that explain the most cell phenotypes
```{r eval=FALSE, echo=FALSE}
#Create dataframe for the random forest
random_forest_input<-rbind(rep(names(cell_types), times = c(dim(cell_types[[1]])[1],dim(cell_types[[2]])[1],dim(cell_types[[3]])[1])),aucell_scores)
rownames(random_forest_input)[1]<-"cell_type"
random_forest_input<-as.data.frame(t(random_forest_input))

#Create a Random Forest model with default parameters
aucell_model <- randomForest(as.factor(cell_type) ~ ., data = random_forest_input, importance = TRUE)
aucell_model_importance<-as.data.frame(importance(aucell_model))
aucell_model_importance<-aucell_model_importance[order(aucell_model_importance$MeanDecreaseAccuracy, decreasing = T),]

#See which Tfs we keep for further interactions
varImpPlot(aucell_model) #Top 30 ones are represented at htis graph so we keep them
aucell_model_importance_top30<-head(rownames(aucell_model_importance),30)
aucell_model_importance_top100<-head(rownames(aucell_model_importance),100)

#Save the tables
write.csv(aucell_model_importance_top30 ,paste0(analysis_directory,"/aucell_model_importance_top30.csv"), row.names = F)
write.csv(aucell_model_importance_top100 ,paste0(analysis_directory,"/aucell_model_importance_top100.csv"), row.names = F)
```

#Heatmaps of the top 30 genes from Random Forest
```{r}
#Open the table
aucell_model_importance_top30<-read.csv(paste0(analysis_directory,"/aucell_model_importance_top30.csv"))[,1]

#Normalized heatmap of these TFs
Heatmap(aucell_scores_norm[aucell_model_importance_top30,],cluster_rows = F,cluster_columns = F, column_labels = rep("",length(colnames(aucell_scores))), column_split = rep(names(cell_types), times = c(dim(cell_types[[1]])[1],dim(cell_types[[2]])[1],dim(cell_types[[3]])[1])))

#Heatmap of averages for each phenotype
aucell_scores_norm_cell_types<-cell_types_cell_ids
for (x in names(cell_types_cell_ids)){
  aucell_scores_norm_cell_types[[x]]<-aucell_scores_norm[aucell_model_importance_top30,][,cell_types_cell_ids[[x]]]
}

aucell_scores_norm_cell_types_means<-lapply(aucell_scores_norm_cell_types, rowMeans)
aucell_scores_norm_cell_types_means<-as.data.frame(aucell_scores_norm_cell_types_means)

Heatmap(as.data.frame(aucell_scores_norm_cell_types_means),cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))

#Save the heatmap
pdf(paste0(analysis_directory,'/figures/aucell_scores_norm_top30_cell_type_average.pdf'),
     width=15,
     height=10)

Heatmap(aucell_scores_norm_cell_types_means,cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))
dev.off()
```

#Distributions of the top 30 genes from Random Forest
```{r}
#TF specific
aucell_scores_norm_top30<-as.data.frame(aucell_scores_norm[aucell_model_importance_top30,])

for (x in rownames(aucell_scores_norm_top30)){
  hist(as.numeric(aucell_scores_norm_top30[x,]), breaks=50, main=x)
}

#Cell type specific (averages of each TF in a cell type)
for (x in names(aucell_scores_norm_cell_types_means)){
  hist(aucell_scores_norm_cell_types_means[[x]], breaks=15, main=x)
}

lapply(aucell_scores_norm_cell_types_means, is.bimodal)
lapply(aucell_scores_norm_cell_types_means, bimodality_coefficient)>0.555

cutoff_thresholds<-c(0,-0.1,0)
names(cutoff_thresholds)<-names(aucell_scores_norm_cell_types_means)
```

#Binarize the top 30 TFs
```{r}
#Binarize dataframe with cell type averages
aucell_scores_norm_cell_types_means_binarized<-aucell_scores_norm_cell_types_means
for (y in colnames(aucell_scores_norm_cell_types_means_binarized)){
  for (x in seq(nrow(aucell_scores_norm_cell_types_means_binarized))){
    if(aucell_scores_norm_cell_types_means_binarized[x,y]>cutoff_thresholds[y]){
      aucell_scores_norm_cell_types_means_binarized[x,y]<-1
    } else {aucell_scores_norm_cell_types_means_binarized[x,y]<-0}
  }
}

Heatmap(as.data.frame(aucell_scores_norm_cell_types_means_binarized),cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))

pdf(paste0(analysis_directory,'/figures/aucell_scores_norm_top30_cell_type_average_binarized.pdf'),
     width=15,
     height=10)

Heatmap(aucell_scores_norm_cell_types_means_binarized,cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))
dev.off()


#Binarize dataframe with all the cells
aucell_scores_norm_cell_types_binarized<-aucell_scores_norm_cell_types
for (z in names(aucell_scores_norm_cell_types_binarized)){
  t_f<-aucell_scores_norm_cell_types[[z]]>cutoff_thresholds[z]
  for (x in seq(ncol(aucell_scores_norm_cell_types[[z]]))){
    pos<-which(t_f[,x]==T)
    aucell_scores_norm_cell_types_binarized[[z]][pos,x]<-1
    aucell_scores_norm_cell_types_binarized[[z]][-pos,x]<-0
  }
}

aucell_scores_norm_cell_types_binarized<-lapply(aucell_scores_norm_cell_types_binarized,function(x){rowSums(x)/ncol(x)})
aucell_scores_norm_cell_types_binarized<-as.data.frame(aucell_scores_norm_cell_types_binarized)

Heatmap(aucell_scores_norm_cell_types_binarized,cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))

pdf(paste0(analysis_directory,'/figures/aucell_scores_norm_top30_cell_type_binarized_percentage.pdf'),
     width=15,
     height=10)

Heatmap(aucell_scores_norm_cell_types_means_binarized,cluster_rows = F,cluster_columns = F, column_labels = names(cell_types))
dev.off()


```

#Network of top 30 TFs from 
```{r}
#Select only interactions that are among top 30 TFs
frequency_summary_top30<-frequency_summary[which(frequency_summary$TF %in% aucell_model_importance_top30),]
frequency_summary_top30<-frequency_summary_top30[which(frequency_summary_top30$target %in% aucell_model_importance_top30),]
vertices.df <- data.frame(unique(c(frequency_summary_top30$TF,frequency_summary_top30$target)))

#Look how many of these interactions are confirmed by cistrome and frequency
frequency_cistrome_summary_top30<-frequency_cistrome_summary[which(frequency_cistrome_summary$TF %in% aucell_model_importance_top30),]
frequency_cistrome_summary_top30<-frequency_cistrome_summary_top30[which(frequency_cistrome_summary_top30$target %in% aucell_model_importance_top30),]

#Look how many of our nodes overlap with the paper
paper_top30_overlap<-paper_nodes[paper_nodes %in% unique(c(frequency_summary_top30$TF,frequency_summary_top30$target))]


## Importing to igraph
g <- graph_from_data_frame(d = frequency_summary_top30, directed = TRUE, vertices = vertices.df)
V(g)$degree <- degree(g)
#colrs <- c("gray50", "tomato")
#V(g)$color <- colrs[V(g)$cistrome]

## Select vertices with highest degrees
v.degree <- degree(g)
v.sorted <- sort(v.degree, decreasing = TRUE)
v.sorted<-names(v.sorted)

g.subset <- induced_subgraph(g, v = v.sorted)
l <- layout_with_fr(g.subset)

plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(V(g.subset)$degree/max(V(g.subset)$degree)*25),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.3),
     edge.width=0.5,
     vertex.frame.color='white')

pdf(paste0(analysis_directory,'/figures/frequency_interactions_top30_plot.pdf'),
     width=15,
     height=20)
plot(g.subset, 
     layout=l,
     edge.arrow.size=0.1,
     vertex.size=(3.5*V(g.subset)$degree/max(V(g.subset)$degree)*4),
     vertex.label.cex=(V(g.subset)$degree/max(V(g.subset)$degree)*1.5),
     edge.width=0.5,
     vertex.frame.color='white')
dev.off()
```


#Analyze input expression of the genes we want to conduct AUCell on 
```{r}
#Subselect the input_for_single_aucell
frequency_regulons_targets<-unique(unlist(regulon_targets))

input_for_single_aucell<-input_for_single_aucell[frequency_regulons_targets[frequency_regulons_targets %in% row.names(input_for_single_aucell)],]

cell_types_input_single_aucell<-cell_types
for (x in names(cell_types)){
  cell_types_input_single_aucell[[x]]<-input_for_single_aucell[,cell_types[[x]]$CELLID]
}

cell_types_scaled<-cell_types_input_single_aucell
for(x in names(cell_types_input_single_aucell)){
  cell_types_scaled[[x]]<-t(scale(t(cell_types_input_single_aucell[[x]])))
}

cell_types_scaled_avrg<-lapply(cell_types_scaled,rowMeans)
cell_types_avrg<-as.data.frame(cell_types_scaled_avrg)

heatmap(as.matrix(cell_types_avrg),Colv = NA, Rowv = NA, scale="none",col = bluered(100))
```

#Another approach for Aucell binarizing
```{r}
#Open all Aucell files from Scenic
aucell_files<-vector("list",length=n)
names(aucell_files)<-seq(n)
for (x in seq(n)){
  aucell_files[[as.character(x)]]<-read.csv(paste0(data_directory,"/SCENIC50/Output_full_genome_new_workflow/run_",as.character(x),"/aucell.csv"),header=T,row.names = 1)
  aucell_files[[as.character(x)]]
}

#Remove "..." from colnames
for (x in names(aucell_files)){
  colnames(aucell_files[[x]])<-gsub(colnames(aucell_files[[x]]),pattern="[...]",replacement="")
}

#Keep only relevant columns and rows
aucell_files_frequency<-aucell_files
for (x in names(aucell_files)){
  aucell_files_frequency[[x]]<-aucell_files[[x]][,colnames(aucell_files[[x]]) %in% frequency_summary_nodes]
}

#Change fromat from dataframes to a nested list
aucell_files_list<-vector("list", length(aucell_files_frequency))
names(aucell_files_list)<-names(aucell_files_frequency)
for (x in names(aucell_files_frequency)){
  sublist<-vector("list",length = dim(aucell_files_frequency[[x]])[2])
  names(sublist)<-colnames(aucell_files_frequency[[x]])
  for(y in colnames(aucell_files_frequency[[x]])){
    sublist[[y]]<-aucell_files_frequency[[x]][,y]
  }
  aucell_files_list[[x]]<-sublist
}

#Remove the scenic runs list levels and unite all genes as one entry
aucell_files_list2<-vector("list", length(frequency_summary_nodes))
names(aucell_files_list2)<-frequency_summary_nodes
for (y in frequency_summary_nodes){
  a<-list()
  for (x in names(aucell_files_list)){
    if (sum(y==names(aucell_files_list[[x]]))!=0){
    pos<-which(names(aucell_files_list[[x]])==y)
    a[[x]]<-aucell_files_list[[x]][[pos]]
    }
  }
  aucell_files_list2[[y]]<-a
}

#Convert entry for each TF into a dataframe, calculate average expression along scenic runs and combine results in a single dataframe
aucell_files_list2<-lapply(aucell_files_list2, as.data.frame)
for (x in names(aucell_files_list2)){
  rownames(aucell_files_list2[[x]])<-cell_annotations$CELLID
}
aucell_files_list2<-lapply(aucell_files_list2, rowMeans)
single_aucell<-as.data.frame(aucell_files_list2)

#Split the dataframe into phenotypes, scale expression for each phenotype and make an average
single_aucell_cell_types<-cell_types
for (x in names(cell_types)){
  single_aucell_cell_types[[x]]<-single_aucell[cell_types[[x]]$CELLID,]
}

single_aucell_cell_types<-lapply(single_aucell_cell_types,scale)
single_aucell_cell_types<-lapply(single_aucell_cell_types,colMeans)
single_average_aucell<-as.data.frame(single_aucell_cell_types)

pdf(paste0(analysis_directory,'/figures/heatmap_average_aucell.pdf'),
     width=15,
     height=40)
Heatmap(as.matrix(single_average_aucell),cluster_rows = F,cluster_columns = F)
dev.off()

#heatmap(as.matrix(single_average_aucell),Colv = NA, Rowv = NA, scale="none",col = bluered(100))
```

#Analyze the distributions of scenic aucell scores
```{r}
bimodaltest_1<-c()
for (x in names(aucell_files_frequency)){
  bimodaltest_1<-append(bimodaltest_1,sum(apply(aucell_files_frequency[[x]], 2, is.bimodal))/dim(aucell_files_frequency[[x]])[2])
}
mean_bimodaltest_1<-mean(bimodaltest_1)

bimodaltest_2<-c()
for (x in names(aucell_files_frequency)){
  bimodaltest_2<-append(bimodaltest_2,sum(apply(aucell_files_frequency[[x]], 2, bimodality_coefficient)>0.555)/dim(aucell_files_frequency[[x]])[2])
}
mean_bimodaltest_2<-mean(bimodaltest_2)
```

